<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>A TodoMVC interop demo, Document Compression</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">

    
    
      <link href="/automerge-rs/dist/css/app.49ec1ced88badbf69e4461b6406cad5a.css" rel="stylesheet">
    

    <link rel="stylesheet" href="/automerge-rs/house.css">

    
      

    

    <meta property="og:title" content="A TodoMVC interop demo, Document Compression" />
<meta property="og:description" content="Automerge 1.0 Demo One promise of local-first applications is easier interoperability of tools on shared data. Today, it is common for client applications to fetch data from an authoritative source hosted as a REST API. This is convenient, but this centralized approach only works when the REST API is available. We will demonstrate an alternative approach similar to how git works, with many independent locally stored copies of the data combined using Automerge." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://inkandswitch.github.io/automerge-rs/post/interop-demo/" />
<meta property="article:published_time" content="2021-01-29T17:00:00+00:00" />
<meta property="article:modified_time" content="2021-01-29T17:00:00+00:00" /><meta itemprop="name" content="A TodoMVC interop demo, Document Compression">
<meta itemprop="description" content="Automerge 1.0 Demo One promise of local-first applications is easier interoperability of tools on shared data. Today, it is common for client applications to fetch data from an authoritative source hosted as a REST API. This is convenient, but this centralized approach only works when the REST API is available. We will demonstrate an alternative approach similar to how git works, with many independent locally stored copies of the data combined using Automerge.">
<meta itemprop="datePublished" content="2021-01-29T17:00:00+00:00" />
<meta itemprop="dateModified" content="2021-01-29T17:00:00+00:00" />
<meta itemprop="wordCount" content="745">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="A TodoMVC interop demo, Document Compression"/>
<meta name="twitter:description" content="Automerge 1.0 Demo One promise of local-first applications is easier interoperability of tools on shared data. Today, it is common for client applications to fetch data from an authoritative source hosted as a REST API. This is convenient, but this centralized approach only works when the REST API is available. We will demonstrate an alternative approach similar to how git works, with many independent locally stored copies of the data combined using Automerge."/>

  </head>

  <body class="">
    
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100 bb">
      <h1 class="f1 mt3 mb1">A TodoMVC interop demo, Document Compression</h1>
      <h3>
        <time class="f6 mv4 dib tracked" datetime="2021-01-29T17:00:00Z">January 29, 2021</time>
      </h3><ul id="byline">
  <li><a href="index.html" id="logo" title="Visit Ink & Switch Home Page"><img src="/automerge-rs/assets/logo-lockup.svg" title="Ink & Switch Logo" /></a></li>
  
  <li class="vcard"><a class="url fn" href="https://github.com/alexjg/" title="Visit Alex Good's Website">Alex Good</a></li>
  
  <li class="vcard"><a class="url fn" href="https://github.com/orionz/" title="Visit Orion Henry's Website">Orion Henry</a></li>
  
  <li class="vcard"><a class="url fn" href="https://github.com/pvh/" title="Visit Peter van Hardenberg's Website">Peter van Hardenberg</a></li>
  
  <li><time class="f6 mv4 dib tracked" datetime="2021-01-29T17:00:00Z">January 29, 2021</time></li>
</ul>
</header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="automerge-10-demo">Automerge 1.0 Demo</h2>
<p>One promise of local-first applications is easier interoperability of tools on shared data. Today, it is common for client applications to fetch data from an authoritative source hosted as a REST API. This is convenient, but this centralized approach only works when the REST API is available. We will demonstrate an alternative approach similar to how <code>git</code> works, with many independent locally stored copies of the data combined using Automerge. Each user has the full history for their documents and can merge changes from any other user.</p>
<p>Although many past Ink &amp; Switch prototypes have used peer-to-peer networking for data distribution in this demo we&rsquo;re trying something different here. In this prototype, we show an alternate <em>file-based</em> approach inspired by the upcoming Automerge 1.0 binary file format. Automerge 1.0 is built around a compact binary representation of a full document&rsquo;s history, well-suited to distributing as a file. An application could distribute these files in almost any way, such as via DropBox or Google Drive, but we have included a trivial Python file-server in the project repository.</p>
<p>This prototype can be found at <a href="https://github.com/inkandswitch/automerge-todomvc-http">https://github.com/inkandswitch/automerge-todomvc-http</a>, including instructions on how to get it up and running.</p>
<h3 id="multiplayer-todomvc-in-react">Multiplayer TodoMVC in React</h3>
<p>Our prototype looks like any old TodoMVC example app, except there&rsquo;s this sidebar with a list of &ldquo;remotes&rdquo;. What&rsquo;s going on with that? If you input a URL in the text box at the top of the sidebar and hit return then the URL will be available to push and pull content from. Here&rsquo;s an example showing two windows sharing data:</p>
<p><img src="./images/react-multibrowser.gif" alt="A gif showing two browser windows with the todo list application open in it. The user adds a remote for each browser to the side bar, then makes edits in each window and shows the edits being synchronised between the two windows"></p>
<p>An important point here is that in this example the two browser windows never push to the same file. Each browser window represents a different user who publishes their own files and invites other users to pull their changes in if they want them.</p>
<h3 id="command-line">Command line</h3>
<p>This is all well and good, but what if you want to automate something here. Maybe you want to run a script which automatically removes tasks if they&rsquo;ve been marked as complete or something. Well that sounds like a task for a shell script, and to do that we&rsquo;ll need a command line client. Happily one of the fruits of implementing Automerge in Rust is a native command line client:</p>
<p><img src="./images/browser-to-cli.png" alt="A gif showing a browser window with a todo list in it and a terminal window. The operator types &lsquo;curl localhost:5000/browser1 | automerge export&rsquo; into the terminal and JSON represting the todo list is printed to the terminal"></p>
<p><code>automerge</code> is a CLI for automerge data. Here we see the <code>export</code> commmand which takes automerge data from a file or standard input and outputs the JSON version of it. One of the neat properties of the automerge format is that the concatenation of two automerge files is an automerge file:</p>
<p><img src="./images/multibrowser-to-cli.gif" alt="A gif showing two browser windows with a todo list in each. The user makes different changes in each one and pushes the changes to two different remotes. Then a terminal window appears and the user fetches the changes from each remote, pipes them through cat and from there through automerge export to show the merged changes"></p>
<p>Well this is great for reading, but we can make changes as well.</p>
<p><img src="./images/cli-to-browser.gif" alt="A gif showing a browser window with a todo list in it, and a terminal window. The operator uses the terminal window to merge the files from the two browser windows and add a new todo list item before pushing to a new peer. The operator then pulls from the new peer in the first browser window to show the merged todo list"></p>
<p>(Note that the syntax for the change command is a first prototype, not a designed solution.)</p>
<h3 id="native-gui-applications">Native GUI Applications</h3>
<p>Command lines are all very well, but one of the reasons to build a Rust library for automerge is so that we can build fast, native applications which integrate with the OS well. Here&rsquo;s the same data loaded in a lightweight GTK application (no Electrons here):</p>
<p><img src="./images/gui-to-browser.gif" alt="A gif showing a browser window with a todo list and list of peers, and a GTK GUI application with a todo list and a list of peers. The operator creates and modifies todo lists in each application and pushes and pulls changes between them"></p>
<h2 id="full-document-compression-feature-complete">Full Document Compression, Feature Complete!</h2>
<p>As we described above, the new Automerge 1.0 release is built around a new compact data representation. The previous version of Automerge didn&rsquo;t describe a data format, and so most folks stored Automerge changes as large JSON blobs. A single character inserted into an Automerge Text field and stored as a plain-text JSON object could be as large as 300 bytes.</p>
<p>Automerge 1.0 is designed around an RLE (run length encoded) compressed format that reduces repeated metadata without loss of history fidelity or custom formats for particular data formats. (More details on this in the future.) The result is that for real-world edits a large collaborative document can have as little as about 1.2 bytes of overhead per character, or about a 200x improvement.</p>
<p>This has been implemented in the Javascript implementation for a while, but full document compression just landed on the Rust side too, so now <code>automerge-wasm</code> is now at full feature parity with the javascript implementation!</p>
<p>The next project for <code>automerge-wasm</code> is going to be official npm packaging, which should allow users to switch between <code>automerge</code> and <code>automerge-wasm</code> as easily as renaming the package. Beyond that, we intend to continue our work on the performance and benchmarking front.</p>
<p>That&rsquo;s all for this update. A full release of Automerge 1.0 is getting closer, and we&rsquo;re eager to help Martin get it over the finish line. See you in a couple of weeks!</p>
<ul class="pa0">
  
</ul>
</div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    

  <script src="/automerge-rs/dist/js/app.50f197db0901b16e3144.js"></script>



  </body>
</html>
